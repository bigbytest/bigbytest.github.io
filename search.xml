<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Guice 基础]]></title>
    <url>%2F2019%2F06%2F01%2Fguice-started%2F</url>
    <content type="text"><![CDATA[What is GuiceGuice是Google开源的为Java 5及后续版本设计的IoC容器，相对于Spring IoC来说Guice具有轻量、启动快等特点。 IoCIoC(Inversion of Control缩写)即控制反转，是面向对象编程中依赖倒置原则的一种体现。所谓反转指的是获得依赖对象的过程被反转了。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。因此控制反转也被称作依赖注入(DI),就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。由于IOC容器生成对象一般是通过反射方式实现，因此在运行效率上会有一定的损耗。 Getting Startedmaven依赖&lt;dependency&gt; &lt;groupId&gt;com.google.inject&lt;/groupId&gt; &lt;artifactId&gt;guice&lt;/artifactId&gt; &lt;version&gt;${guice.version}&lt;/version&gt; &lt;/dependency&gt; 接口注入public class VisitServiceImpl implements IVisitService { @Inject private ILogService logService; public void vist(String user) { this.logService.log(user + " is visit ..."); } } 接口绑定Guice中接口和实现在类中进行绑定,可通过继承com.google.inject.AbstractModule在configure()方法中进行绑定。 public class VisitModule extends AbstractModule { @Override protected void configure() { bind(ILogService.class).to(JdkLogServiceImpl.class); bind(IVisitService.class).to(VisitServiceImpl.class); } } 实例获取public static void main(String[] args) { // 加载Module,创建注射器 Injector injector = Guice.createInjector(new VisitModule()); // 获取IVisitService接口实例 IVisitService visitor = injector.getInstance(IVisitService.class); visitor.vist("jack"); } Bindings链式绑定public class BillingModule extends AbstractModule { @Override protected void configure() { // TransactionLog可直接绑定到MySqlDatabaseTransactionLog bind(TransactionLog.class).to(DatabaseTransactionLog.class); bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class); } } 注解绑定 定义注解 一个注解只能用于绑定一个接口实现，否则Guice将会报错。 /**BindingAnnotation定义绑定注解*/ @BindingAnnotation @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME) public @interface PayPal {} 依赖注入 public class RealBillingService implements BillingService { @Inject public RealBillingService(@PayPal CreditCardProcessor processor, TransactionLog transactionLog) { ... } } 绑定 public class BillingModule extends AbstractModule { @Override protected void configure() { bind(CreditCardProcessor.class) // 注解绑定 .annotatedWith(PayPal.class) .to(PayPalCreditCardProcessor.class); } } @Named注解绑定public class RealBillingService implements BillingService { @Inject public RealBillingService(@Named("Checkout") CreditCardProcessor processor, TransactionLog transactionLog) { ... } } public class BillingModule extends AbstractModule { @Override protected void configure() { bind(CreditCardProcessor.class) // 注解绑定到名称"Checkout" .annotatedWith(Names.named("Checkout")) .to(CheckoutCreditCardProcessor.class); } } @Named绑定在Guice编译过程中不会进行映射关系检查。由于单个自定义注解只能用于绑定一对接口映射关系，因此@Named绑定相对更加灵活一些。 实例绑定实例绑定可以直接将类型与其对应实例进行绑定，常用于没有其他依赖的目标类型如基本类型。对于实例化较慢的目标类型不建议使用实例绑定，因为它会拖慢整个程序的启动过程，推荐使用@Providers注解方法绑定。 public class BillingModule extends AbstractModule { @Override protected void configure() { bind(String.class) .annotatedWith(Names.named("JDBC URL")) .toInstance("jdbc:mysql://localhost/pizza"); bind(Integer.class) .annotatedWith(Names.named("login timeout seconds")) .toInstance(10); } } @Providers注解方法绑定该种绑定方式只能定义在Module类中,@Providers注解方法的返回类型即为目标接口类型。如果该方法同时存在自定义注解或@Named，容器也会自动完成注解绑定。 public class BillingModule extends AbstractModule { @Override protected void configure() { ... } @Provides @PayPal TransactionLog provideTransactionLog(@Named("PayPal API key") String apiKey) { DatabaseTransactionLog transactionLog = new DatabaseTransactionLog(); transactionLog.setJdbcUrl("jdbc:mysql://localhost/pizza"); transactionLog.setThreadPoolSize(30); return transactionLog; } } Provider绑定如果@Providers注解方法过程比较复杂，则可以将该过程迁移到单独的类中。该类只需实现Provider接口即可 public interface Provider&lt;T&gt; { T get(); } /** * Provider */ public class DatabaseTransactionLogProvider implements Provider&lt;TransactionLog&gt; { private final Connection connection; @Inject public DatabaseTransactionLogProvider(Connection connection) { this.connection = connection; } public TransactionLog get() { DatabaseTransactionLog transactionLog = new DatabaseTransactionLog(); transactionLog.setConnection(connection); return transactionLog; } } public class BillingModule extends AbstractModule { @Override protected void configure() { // 绑定 bind(TransactionLog.class) .toProvider(DatabaseTransactionLogProvider.class); } } Untargeted Bindings如果某个类没有目标绑定接口，或者需要直接注入某个具体的类，则可使用该种绑定方式。需要注意的是如果绑定过程中使用到了注解绑定，则必须通过to方法指定绑定目标，不过该绑定目标可以是当前具体类本身。 public class BillingModule extends AbstractModule { @Override protected void configure() { // 无目标绑定 bind(AnotherConcreteClass.class).in(Singleton.class); // 注解绑定需要指定绑定目标 bind(MyConcreteClass.class) .annotatedWith(Names.named("foo")) .to(MyConcreteClass.class); } } 构造绑定构造绑定是Guice3.0之后的新特性，一般用于无法直接在构造方法使用@Inject的情况，如目标对象在第三方类库中。 public class BillingModule extends AbstractModule { @Override protected void configure() { try { bind(TransactionLog.class).toConstructor(DatabaseTransactionLog.class.getConstructor(DatabaseConnection.class)); } catch (NoSuchMethodException e) { addError(e); } } } Built-in BindingsJust-In-Time Bindings Eligible Constructors public class PayPalCreditCardProcessor implements CreditCardProcessor { private final String apiKey; @Inject public PayPalCreditCardProcessor(@Named("PayPal API key") String apiKey) { this.apiKey = apiKey; } } @ImplementedBy @ImplementedBy(PayPalCreditCardProcessor.class) public interface CreditCardProcessor { ChargeResult charge(String amount, CreditCard creditCard) throws UnreachableException; } // 等价于 bind(CreditCardProcessor.class).to(PayPalCreditCardProcessor.class); @ProvidedBy @ProvidedBy(DatabaseTransactionLogProvider.class) public interface TransactionLog { void logConnectException(UnreachableException e); void logChargeResult(ChargeResult result); } // 等价于 bind(TransactionLog.class).toProvider(DatabaseTransactionLogProvider.class); Scopes默认情况下,Guice容器每次都会返回一个新的实例，可通过Scopes在实例绑定时修改其生命周期。 @Singleton /**单例*/ public class InMemoryTransactionLog implements TransactionLog { /* everything here should be threadsafe! */ } /**每次通过Injector获取CreditCardProcessor实例时都会重新创建*/ bind(CreditCardProcessor.class).to(PayPalCreditCardProcessor.class); /**bind时指定单例, lazy模式*/ bind(TransactionLog.class).to(InMemoryTransactionLog.class).in(Singleton.class); /**bind时指定单例, eager模式*/ bind(TransactionLog.class).to(InMemoryTransactionLog.class).asEagerSingleton(); /**Request级单例，类似的还有@SessionScoped以及@RequestScoped*/ bind(UserPreferences.class).toProvider(UserPreferencesProvider.class).in(ServletScopes.REQUEST); Injections 注入方式 构造注入如果目标类没有提供@Inject注解的构造方法,Guice默认会尝试使用public无参构造方法创建实例。 public class RealBillingService implements BillingService { private final CreditCardProcessor processorProvider; private final TransactionLog transactionLogProvider; @Inject public RealBillingService(CreditCardProcessor processorProvider, TransactionLog transactionLogProvider) { this.processorProvider = processorProvider; this.transactionLogProvider = transactionLogProvider; } } 方法注入 public class PayPalCreditCardProcessor implements CreditCardProcessor { private static final String DEFAULT_API_KEY = "development-use-only"; private String apiKey = DEFAULT_API_KEY; @Inject public void setApiKey(@Named("PayPal API key") String apiKey) { this.apiKey = apiKey; } } 属性注入 public class DatabaseTransactionLogProvider implements Provider { @Inject Connection connection; public TransactionLog get() { return new DatabaseTransactionLog(connection); } } 可选注入当Inject没有注入属性值时，该属性可使用默认值。 public class PayPalCreditCardProcessor implements CreditCardProcessor { private static final String DEFAULT_API_KEY = "development-use-only"; private String apiKey = DEFAULT_API_KEY; @Inject(optional=true) public void setApiKey(@Named("PayPal API key") String apiKey) { this.apiKey = apiKey; } } 静态注入 class ProcessorFactory { // 静态注入 @Inject static Provider processorProvider; } @Override public void configure() { // 静态注入 requestStaticInjection(ProcessorFactory.class); ... } 参考Guice官方文档]]></content>
      <tags>
        <tag>Guice</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
